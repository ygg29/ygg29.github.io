<!DOCTYPE html>
<html lang="zh-CH">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-my.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-my.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-my.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.yshaw.cn","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="原文： Method Dispatch in Swift 作者： Brain King 译者： kemchenj **注：**之前看了很多关于 Swift 派发机制的内容, 但感觉没有一篇能够彻底讲清楚这件事情, 看完了这篇文章之后我对 Swift 的派发机制才建立起了初步的认知.">
<meta property="og:type" content="article">
<meta property="og:title" content="【译文】swift 派发机制">
<meta property="og:url" content="http://blog.yshaw.cn/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="友友的开发笔记">
<meta property="og:description" content="原文： Method Dispatch in Swift 作者： Brain King 译者： kemchenj **注：**之前看了很多关于 Swift 派发机制的内容, 但感觉没有一篇能够彻底讲清楚这件事情, 看完了这篇文章之后我对 Swift 的派发机制才建立起了初步的认知.">
<meta property="og:locale" content="zh_CH">
<meta property="og:image" content="https://raizlabscom-wpengine.netdna-ssl.com/dev/wp-content/uploads/sites/10/2016/12/Summary-3-755x255.png">
<meta property="og:image" content="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/virtual-dispatch.png">
<meta property="og:image" content="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/message-dispatch.png">
<meta property="og:image" content="https://raizlabs.wpengine.com/dev/wp-content/uploads/sites/10/2016/12/Defaults-1-768x503.png">
<meta property="og:image" content="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Modifiers-1.png">
<meta property="og:image" content="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Summary-3.png">
<meta property="article:published_time" content="2018-06-21T06:12:28.000Z">
<meta property="article:modified_time" content="2021-09-06T13:04:35.374Z">
<meta property="article:author" content="You Shaw">
<meta property="article:tag" content="runtime">
<meta property="article:tag" content="函数派发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raizlabscom-wpengine.netdna-ssl.com/dev/wp-content/uploads/sites/10/2016/12/Summary-3-755x255.png">


<link rel="canonical" href="http://blog.yshaw.cn/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CH'
  };
</script>

  <title>【译文】swift 派发机制 | 友友的开发笔记</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">友友的开发笔记</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">正经人谁写博客呀</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E5%8F%91%E6%96%B9%E5%BC%8F-Types-of-Dispatch"><span class="nav-number">1.</span> <span class="nav-text">派发方式 (Types of Dispatch )</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%B4%BE%E5%8F%91-Direct-Dispatch"><span class="nav-number">1.1.</span> <span class="nav-text">直接派发 (Direct Dispatch)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%A1%A8%E6%B4%BE%E5%8F%91-Table-Dispatch"><span class="nav-number">1.2.</span> <span class="nav-text">函数表派发 (Table Dispatch )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B4%BE%E5%8F%91-Message-Dispatch"><span class="nav-number">1.3.</span> <span class="nav-text">消息机制派发 (Message Dispatch )</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Swift-%E7%9A%84%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">Swift 的派发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%8D%E7%BD%AE-Location-Matters"><span class="nav-number">2.1.</span> <span class="nav-text">声明的位置 (Location Matters)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Reference-Type-Matters"><span class="nav-number">2.2.</span> <span class="nav-text">引用类型 (Reference Type Matters)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E6%B4%BE%E5%8F%91%E6%96%B9%E5%BC%8F-Specifying-Dispatch-Behavior"><span class="nav-number">2.3.</span> <span class="nav-text">指定派发方式 (Specifying Dispatch Behavior)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">2.3.1.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic"><span class="nav-number">2.3.2.</span> <span class="nav-text">dynamic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#objc-nonobjc"><span class="nav-number">2.3.3.</span> <span class="nav-text">@objc &amp; @nonobjc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final-objc"><span class="nav-number">2.3.4.</span> <span class="nav-text">final @objc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#inline"><span class="nav-number">2.3.5.</span> <span class="nav-text">@inline</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%80%BB%E7%BB%93-Modifier-Overview"><span class="nav-number">2.3.6.</span> <span class="nav-text">修饰符总结 (Modifier Overview)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E7%9A%84%E9%83%BD%E4%BC%9A%E8%A2%AB%E4%BC%98%E5%8C%96-Visibility-Will-Optimize"><span class="nav-number">2.4.</span> <span class="nav-text">可见的都会被优化 (Visibility Will Optimize)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E5%8F%91%E6%80%BB%E7%BB%93-Dispatch-Summary"><span class="nav-number">2.4.1.</span> <span class="nav-text">派发总结 (Dispatch Summary)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NSObject-%E4%BB%A5%E5%8F%8A%E5%8A%A8%E6%80%81%E6%80%A7%E7%9A%84%E6%8D%9F%E5%A4%B1-NSObject-and-the-Loss-of-Dynamic-Behavior"><span class="nav-number">3.</span> <span class="nav-text">NSObject 以及动态性的损失 (NSObject and the Loss of Dynamic Behavior)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSObject-%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E6%B4%BE%E5%8F%91-Table-Dispatch-in-NSObject"><span class="nav-number">3.1.</span> <span class="nav-text">NSObject 的函数表派发 (Table Dispatch in NSObject)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E5%8F%91%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E5%8C%96%E7%A0%B4%E5%9D%8F%E4%BA%86-NSObject-%E7%9A%84%E5%8A%9F%E8%83%BD-Dispatch-Upgrades-Breaking-NSObject-Features"><span class="nav-number">3.2.</span> <span class="nav-text">派发方式的优化破坏了 NSObject 的功能 (Dispatch Upgrades Breaking NSObject Features)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NSObject-%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%80%89%E6%8B%A9-NSObject-as-a-Choice"><span class="nav-number">3.3.</span> <span class="nav-text">NSObject 作为一个选择 (NSObject as a Choice)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7%E5%A3%B0%E6%98%8E-Implicit-Dynamic-Modification"><span class="nav-number">3.4.</span> <span class="nav-text">显式的动态性声明 (Implicit Dynamic Modification)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Error-%E4%BB%A5%E5%8F%8A-Bug-Errors-and-Bugs"><span class="nav-number">4.</span> <span class="nav-text">Error 以及 Bug (Errors and Bugs)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SR-584"><span class="nav-number">4.1.</span> <span class="nav-text">SR-584</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SR-103"><span class="nav-number">4.2.</span> <span class="nav-text">SR-103</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E5%AE%83-bug-Other-bugs"><span class="nav-number">4.3.</span> <span class="nav-text">其它 bug (Other bugs)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E8%B6%A3%E7%9A%84-Error-Interesting-Error"><span class="nav-number">4.4.</span> <span class="nav-text">有趣的 Error (Interesting Error)</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="You Shaw"
      src="/Users/hexo_images/005PIzc6ly1g5pyr7ct7lj31op1op4qp.jpg">
  <p class="site-author-name" itemprop="name">You Shaw</p>
  <div class="site-description" itemprop="description">潘驴邓小闲</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/ygg29" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ygg29" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiayou29@163.com" title="E-Mail → mailto:xiayou29@163.com" rel="noopener" target="_blank"><i class="163 fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.yuhanle.com/" title="http:&#x2F;&#x2F;www.yuhanle.com&#x2F;" rel="noopener" target="_blank">煜寒了</a>
        </li>
    </ul>
  </div>

      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CH">
    <link itemprop="mainEntityOfPage" href="http://blog.yshaw.cn/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Users/hexo_images/005PIzc6ly1g5pyr7ct7lj31op1op4qp.jpg">
      <meta itemprop="name" content="You Shaw">
      <meta itemprop="description" content="潘驴邓小闲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="友友的开发笔记">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          【译文】swift 派发机制
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-06-21 14:12:28" itemprop="dateCreated datePublished" datetime="2018-06-21T14:12:28+08:00">2018-06-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%96%87%E7%AB%A0%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">文章翻译</span></a>
        </span>
    </span>

  
    <span id="/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/" class="post-meta-item leancloud_visitors" data-flag-title="【译文】swift 派发机制" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p><strong>原文：</strong> <a target="_blank" rel="noopener" href="https://www.raizlabs.com/dev/2016/12/swift-method-dispatch/?utm_campaign=This%2BWeek%2Bin%2BSwift&amp;utm_medium=email&amp;utm_source=This_Week_in_Swift_114">Method Dispatch in Swift</a><br>
<strong>作者：</strong> <a target="_blank" rel="noopener" href="https://www.raizlabs.com/dev/author/brian-kingraizlabs-com/">Brain King</a><br>
<strong>译者：</strong> <a target="_blank" rel="noopener" href="https://kemchenj.github.io/">kemchenj</a></p>
<p>**注：**之前看了很多关于 Swift 派发机制的内容, 但感觉没有一篇能够彻底讲清楚这件事情, 看完了这篇文章之后我对 Swift 的派发机制才建立起了初步的认知.</p>
</blockquote>
<a id="more"></a>
<p><img src="https://raizlabscom-wpengine.netdna-ssl.com/dev/wp-content/uploads/sites/10/2016/12/Summary-3-755x255.png" alt="img"></p>
<p>一张表总结引用类型, 修饰符和它们对于 Swift 函数派发方式的影响.</p>
<p>函数派发就是程序判断使用哪种途径去调用一个函数的机制. 每次函数被调用时都会被触发, 但你又不会太留意的一个东西. 了解派发机制对于写出高性能的代码来说很有必要, 而且也能够解释很多 Swift 里”奇怪”的行为.</p>
<p>编译型语言有三种基础的函数派发方式: <strong>直接派发(Direct Dispatch)</strong>, <strong>函数表派发(Table Dispatch)</strong> 和 <strong>消息机制派发(Message Dispatch)</strong>, 下面我会仔细讲解这几种方式. 大多数语言都会支持一到两种, Java 默认使用函数表派发, 但你可以通过 <code>final</code> 修饰符修改成直接派发. C++ 默认使用直接派发, 但可以通过加上 <code>virtual</code> 修饰符来改成函数表派发. 而 Objective-C 则总是使用消息机制派发, 但允许开发者使用 C 直接派发来获取性能的提高. 这样的方式非常好, 但也给很多开发者带来了困扰,</p>
<blockquote>
<p>译者注: 想要了解 Swift 底层结构的人, 极度推荐<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=ERYNyrfXjlg">这段视频</a></p>
</blockquote>
<h2 id="派发方式-Types-of-Dispatch"><a class="header-anchor" href="#派发方式-Types-of-Dispatch">¶</a>派发方式 (Types of Dispatch )</h2>
<p>程序派发的目的是为了告诉 CPU 需要被调用的函数在哪里, 在我们深入 Swift 派发机制之前, 先来了解一下这三种派发方式, 以及每种方式在动态性和性能之间的取舍.</p>
<h3 id="直接派发-Direct-Dispatch"><a class="header-anchor" href="#直接派发-Direct-Dispatch">¶</a>直接派发 (Direct Dispatch)</h3>
<p>直接派发是最快的, 不止是因为需要调用的指令集会更少, 并且编译器还能够有很大的优化空间, 例如函数内联等, 但这不在这篇博客的讨论范围. 直接派发也有人称为静态调用.</p>
<p>然而, 对于编程来说直接调用也是最大的局限, 而且因为缺乏动态性所以没办法支持继承.</p>
<h3 id="函数表派发-Table-Dispatch"><a class="header-anchor" href="#函数表派发-Table-Dispatch">¶</a>函数表派发 (Table Dispatch )</h3>
<p>函数表派发是编译型语言实现动态行为最常见的实现方式. 函数表使用了一个数组来存储类声明的每一个函数的指针. 大部分语言把这个称为 “virtual table”(虚函数表), Swift 里称为 “witness table”. 每一个类都会维护一个函数表, 里面记录着类所有的函数, 如果父类函数被 override 的话, 表里面只会保存被 override 之后的函数. 一个子类新添加的函数, 都会被插入到这个数组的最后. 运行时会根据这一个表去决定实际要被调用的函数.</p>
<p>举个例子, 看看下面两个类:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>: <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个情况下, 编译器会创建两个函数表, 一个是 <code>ParentClass</code> 的, 另一个是 <code>ChildClass</code>的:</p>
<p><img src="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/virtual-dispatch.png" alt="img"></p>
<p>这张表展示了 ParentClass 和 ChildClass 虚数表里 method1, method2, method3 在内存里的布局.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj <span class="operator">=</span> <span class="type">ChildClass</span>()</span><br><span class="line">obj.method2()</span><br></pre></td></tr></table></figure>
<p>当一个函数被调用时, 会经历下面的几个过程:</p>
<ol>
<li>读取对象 <code>0xB00</code> 的函数表.</li>
<li>读取函数指针的索引. 在这里, <code>method2</code> 的索引是1(偏移量), 也就是 <code>0xB00 + 1</code>.</li>
<li>跳到 <code>0x222</code> (函数指针指向 0x222)</li>
</ol>
<p>查表是一种简单, 易实现, 而且性能可预知的方式. 然而, 这种派发方式比起直接派发还是慢一点. 从字节码角度来看, 多了两次读和一次跳转, 由此带来了性能的损耗. 另一个慢的原因在于编译器可能会由于函数内执行的任务导致无法优化. (如果函数带有副作用的话)</p>
<p>这种基于数组的实现, 缺陷在于函数表无法拓展. 子类会在虚数函数表的最后插入新的函数, 没有位置可以让 extension 安全地插入函数. 这篇<a target="_blank" rel="noopener" href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001922.html">提案</a>很详细地描述了这么做的局限.</p>
<h3 id="消息机制派发-Message-Dispatch"><a class="header-anchor" href="#消息机制派发-Message-Dispatch">¶</a>消息机制派发 (Message Dispatch )</h3>
<p>消息机制是调用函数最动态的方式. 也是 Cocoa 的基石, 这样的机制催生了 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a>, <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/uikit/uiappearance">UIAppearence</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content///documentation/Cocoa/Conceptual/CoreData/index.html">CoreData</a> 等功能. 这种运作方式的关键在于开发者可以在运行时改变函数的行为. 不止可以通过 <a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2010-01-29-method-replacement-for-fun-and-profit.html">swizzling</a> 来改变, 甚至可以用 <a target="_blank" rel="noopener" href="http://stackoverflow.com/a/38878119/255489">isa-swizzling</a> 修改对象的继承关系, 可以在面向对象的基础上实现自定义派发.</p>
<p>举个例子, 看看下面两个类:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span>: <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">method2</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">    <span class="keyword">dynamic</span> <span class="function"><span class="keyword">func</span> <span class="title">method3</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 会用树来构建这种继承关系:</p>
<p><img src="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/message-dispatch.png" alt="img"></p>
<p>这张图很好地展示了 Swift 如何使用树来构建类和子类.</p>
<p>当一个消息被派发, 运行时会顺着类的继承关系向上查找应该被调用的函数. 如果你觉得这样做效率很低, 它确实很低! 然而, 只要缓存建立了起来, 这个查找过程就会通过缓存来把性能提高到和函数表派发一样快. 但这只是消息机制的原理, 这里有<a target="_blank" rel="noopener" href="http://www.friday.com/bbum/2009/12/18/objc_msgsend-part-1-the-road-map/">一篇文章</a>很深入的讲解了具体的技术细节.</p>
<h2 id="Swift-的派发机制"><a class="header-anchor" href="#Swift-的派发机制">¶</a>Swift 的派发机制</h2>
<p>那么, 到底 Swift 是怎么派发的呢? 我没能找到一个很简明扼要的答案, 但这里有四个选择具体派发方式的因素存在:</p>
<ol>
<li><strong>声明的位置</strong></li>
<li><strong>引用类型</strong></li>
<li><strong>特定的行为</strong></li>
<li><strong>显式地优化</strong>(Visibility Optimizations)</li>
</ol>
<p>在解释这些因素之前, 我有必要说清楚, Swift 没有在文档里具体写明什么时候会使用函数表什么时候使用消息机制. 唯一的承诺是使用 <code>dynamic</code> 修饰的时候会通过 Objective-C 的运行时进行消息机制派发. 下面我写的所有东西, 都只是我在 Swift 3.0 里测试出来的结果, 并且很可能在之后的版本更新里进行修改.</p>
<h3 id="声明的位置-Location-Matters"><a class="header-anchor" href="#声明的位置-Location-Matters">¶</a>声明的位置 (Location Matters)</h3>
<p>在 Swift 里, 一个函数有两个可以声明的位置: 类型声明的作用域, 和 extension. 根据声明类型的不同, 也会有不同的派发方式.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mainMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子里, <code>mainMethod</code> 会使用函数表派发, 而 <code>extensionMethod</code> 则会使用直接派发. 当我第一次发现这件事情的时候觉得很意外, 直觉上这两个函数的声明方式并没有那么大的差异. 下面是我根据类型, 声明位置总结出来的函数派发方式的表格.</p>
<p><img src="https://raizlabs.wpengine.com/dev/wp-content/uploads/sites/10/2016/12/Defaults-1-768x503.png" alt="img"></p>
<p>这张表格展示了默认情况下 Swift 使用的派发方式.</p>
<p>总结起来有这么几点:</p>
<ul>
<li>值类型总是会使用直接派发, 简单易懂</li>
<li>而协议和类的 extension 都会使用直接派发</li>
<li><code>NSObject</code> 的 extension 会使用消息机制进行派发</li>
<li><code>NSObject</code> 声明作用域里的函数都会使用函数表进行派发.</li>
<li>协议里声明的, 并且带有默认实现的函数会使用函数表进行派发</li>
</ul>
<h3 id="引用类型-Reference-Type-Matters"><a class="header-anchor" href="#引用类型-Reference-Type-Matters">¶</a>引用类型 (Reference Type Matters)</h3>
<p>引用的类型决定了派发的方式. 这很显而易见, 但也是决定性的差异. 一个比较常见的疑惑, 发生在一个协议拓展和类型拓展同时实现了同一个函数的时候.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>: <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyStruct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;结构体&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;协议&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myStruct <span class="operator">=</span> <span class="type">MyStruct</span>()</span><br><span class="line"><span class="keyword">let</span> proto: <span class="type">MyProtocol</span> <span class="operator">=</span> myStruct</span><br><span class="line"> </span><br><span class="line">myStruct.extensionMethod() <span class="comment">// -&gt; “结构体”</span></span><br><span class="line">proto.extensionMethod() <span class="comment">// -&gt; “协议”</span></span><br></pre></td></tr></table></figure>
<p>刚接触 Swift 的人可能会认为 <code>proto.extensionMethod()</code> 调用的是结构体里的实现. 但是, 引用的类型决定了派发的方式, 协议拓展里的函数会使用直接调用. 如果把 <code>extensionMethod</code> 的声明移动到协议的声明位置的话, 则会使用函数表派发, 最终就会调用结构体里的实现. 并且要记得, 如果两种声明方式都使用了直接派发的话, 基于直接派发的运作方式, 我们不可能实现预想的 <code>override</code> 行为. 这对于很多从 Objective-C 过渡过来的开发者是反直觉的.</p>
<p>Swift JIRA(缺陷跟踪管理系统) 也发现了几个 <a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-1422">bugs</a>, Swfit-Evolution 邮件列表里有<a target="_blank" rel="noopener" href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000983.html">一大堆</a><a target="_blank" rel="noopener" href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/thread.html#983">讨论</a>, 也有<a target="_blank" rel="noopener" href="https://nomothetis.svbtle.com/the-ghost-of-swift-bugs-future">一大堆博客</a>讨论过这个. 但是, 这好像是故意这么做的, 虽然官方文档没有提过这件事情</p>
<h3 id="指定派发方式-Specifying-Dispatch-Behavior"><a class="header-anchor" href="#指定派发方式-Specifying-Dispatch-Behavior">¶</a>指定派发方式 (Specifying Dispatch Behavior)</h3>
<p>Swift 有一些修饰符可以指定派发方式.</p>
<h4 id="final"><a class="header-anchor" href="#final">¶</a>final</h4>
<p><code>final</code> 允许类里面的函数使用直接派发. 这个修饰符会让函数失去动态性. 任何函数都可以使用这个修饰符, 就算是 extension 里本来就是直接派发的函数. 这也会让 Objective-C 的运行时获取不到这个函数, 不会生成相应的 selector.</p>
<h4 id="dynamic"><a class="header-anchor" href="#dynamic">¶</a>dynamic</h4>
<p><code>dynamic</code> 可以让类里面的函数使用消息机制派发. 使用 <code>dynamic</code>, 必须导入 <code>Foundation</code> 框架, 里面包括了 <code>NSObject</code> 和 Objective-C 的运行时. <code>dynamic</code> 可以让声明在 extension 里面的函数能够被 override. <code>dynamic</code> 可以用在所有 <code>NSObject</code> 的子类和 Swift 的原声类.</p>
<h4 id="objc-nonobjc"><a class="header-anchor" href="#objc-nonobjc">¶</a>@objc &amp; @nonobjc</h4>
<p><code>@objc</code> 和 <code>@nonobjc</code> 显式地声明了一个函数是否能被 Objective-C 的运行时捕获到. 使用 <code>@objc</code> 的典型例子就是给 selector 一个命名空间 <code>@objc(abc_methodName)</code>, 让这个函数可以被 Objective-C 的运行时调用. <code>@nonobjc</code> 会改变派发的方式, 可以用来禁止消息机制派发这个函数, 不让这个函数注册到 Objective-C 的运行时里. 我不确定这跟 <code>final</code> 有什么区别, 因为从使用场景来说也几乎一样. 我个人来说更喜欢 <code>final</code>, 因为意图更加明显.</p>
<blockquote>
<p>译者注: 我个人感觉, 这这主要是为了跟 Objective-C 兼容用的, <code>final</code> 等原生关键词, 是让 Swift 写服务端之类的代码的时候可以有原生的关键词可以使用.</p>
</blockquote>
<h4 id="final-objc"><a class="header-anchor" href="#final-objc">¶</a>final @objc</h4>
<p>可以在标记为 <code>final</code> 的同时, 也使用 <code>@objc</code> 来让函数可以使用消息机制派发. 这么做的结果就是, 调用函数的时候会使用直接派发, 但也会在 Objective-C 的运行时里注册响应的 selector. 函数可以响应 <code>perform(selector:)</code> 以及别的 Objective-C 特性, 但在直接调用时又可以有直接派发的性能.</p>
<h4 id="inline"><a class="header-anchor" href="#inline">¶</a>@inline</h4>
<p>Swift 也支持 <code>@inline</code>, 告诉编译器可以使用直接派发. 有趣的是, <code>dynamic @inline(__always) func dynamicOrDirect() &#123;&#125;</code> 也可以通过编译! 但这也只是告诉了编译器而已, 实际上这个函数还是会使用消息机制派发. 这样的写法看起来像是一个未定义的行为, 应该避免这么做.</p>
<h4 id="修饰符总结-Modifier-Overview"><a class="header-anchor" href="#修饰符总结-Modifier-Overview">¶</a>修饰符总结 (Modifier Overview)</h4>
<p><img src="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Modifiers-1.png" alt="img"></p>
<p>这张图总结这些修饰符对于 Swift 派发方式的影响.</p>
<p>如果你想查看上面所有例子的话, 请看<a target="_blank" rel="noopener" href="https://gist.github.com/KingOfBrian/778dc93bffddf25b2c414360727c273b#file-message-swift">这里</a>.</p>
<h3 id="可见的都会被优化-Visibility-Will-Optimize"><a class="header-anchor" href="#可见的都会被优化-Visibility-Will-Optimize">¶</a>可见的都会被优化 (Visibility Will Optimize)</h3>
<p>Swift 会尽最大能力去优化函数派发的方式. 例如, 如果你有一个函数从来没有 override, Swift 就会检车并且在可能的情况下使用直接派发. 这个优化大多数情况下都表现得很好, 但对于使用了 target / action 模式的 Cocoa 开发者就不那么友好了. 例如:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    navigationItem.rightBarButtonItem <span class="operator">=</span> <span class="type">UIBarButtonItem</span>(</span><br><span class="line">        title: <span class="string">&quot;登录&quot;</span>, style: .plain, target: <span class="literal">nil</span>,</span><br><span class="line">        action: <span class="keyword">#selector</span>(<span class="type">ViewController</span>.signInAction)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">signInAction</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里编译器会抛出一个错误: <code>Argument of '#selector' refers to a method that is not exposed to Objective-C (Objective-C 无法获取 #selector 指定的函数)</code>. 你如果记得 Swift 会把这个函数优化为直接派发的话, 就能理解这件事情了. 这里修复的方式很简单: 加上 <code>@objc</code> 或者 <code>dynamic</code> 就可以保证 Objective-C 的运行时可以获取到函数了. 这种类型的错误也会发生在<code>UIAppearance</code> 上, 依赖于 proxy 和 <code>NSInvocation</code> 的代码.</p>
<p>另一个需要注意的是, 如果你没有使用 <code>dynamic</code> 修饰的话, 这个优化会默认让 KVO 失效. 如果一个属性绑定了 KVO 的话, 而这个属性的 getter 和 setter 会被优化为直接派发, 代码依旧可以通过编译, 不过动态生成的 KVO 函数就不会被触发.</p>
<p>Swift 的博客有一篇<a target="_blank" rel="noopener" href="https://developer.apple.com/swift/blog/?id=27">很赞的文章</a>描述了相关的细节, 和这些优化背后的考虑.</p>
<h4 id="派发总结-Dispatch-Summary"><a class="header-anchor" href="#派发总结-Dispatch-Summary">¶</a>派发总结 (Dispatch Summary)</h4>
<p>这里有一大堆规则要记住, 所以我整理了一个表格:</p>
<p><img src="http://www.raizlabs.com/dev/wp-content/uploads/sites/10/2016/12/Summary-3.png" alt="img"></p>
<p>这张表总结引用类型, 修饰符和它们对于 Swift 函数派发的影响</p>
<h2 id="NSObject-以及动态性的损失-NSObject-and-the-Loss-of-Dynamic-Behavior"><a class="header-anchor" href="#NSObject-以及动态性的损失-NSObject-and-the-Loss-of-Dynamic-Behavior">¶</a>NSObject 以及动态性的损失 (NSObject and the Loss of Dynamic Behavior)</h2>
<p>不久之前还有一群 Cocoa 开发者<a target="_blank" rel="noopener" href="http://mjtsai.com/blog/2016/05/21/dynamic-swift-2/">讨论动态行为带来的问题</a>. 这段讨论很有趣, 提了一大堆不同的观点. 我希望可以在这里继续探讨一下, 有几个 Swift 的派发方式我觉得损害了动态性, 顺便说一下我的解决方案.</p>
<h3 id="NSObject-的函数表派发-Table-Dispatch-in-NSObject"><a class="header-anchor" href="#NSObject-的函数表派发-Table-Dispatch-in-NSObject">¶</a>NSObject 的函数表派发 (Table Dispatch in NSObject)</h3>
<p>上面, 我提到 <code>NSObject</code> 子类定义里的函数会使用函数表派发. 但我觉得很迷惑, 很难解释清楚, 并且由于下面几个原因, 这也只带来了一点点性能的提升:</p>
<ul>
<li>大部分 <code>NSObject</code> 的子类都是在 <code>obj_msgSend</code> 的基础上构建的. 我很怀疑这些派发方式的优化, 实际到底会给 Cocoa 的子类带来多大的提升.</li>
<li>大多数 Swift 的 <code>NSObject</code> 子类都会使用 extension 进行拓展, 都没办法使用这种优化.</li>
</ul>
<p>最后, 有一些小细节会让派发方式变得很复杂.</p>
<h3 id="派发方式的优化破坏了-NSObject-的功能-Dispatch-Upgrades-Breaking-NSObject-Features"><a class="header-anchor" href="#派发方式的优化破坏了-NSObject-的功能-Dispatch-Upgrades-Breaking-NSObject-Features">¶</a>派发方式的优化破坏了 NSObject 的功能 (Dispatch Upgrades Breaking NSObject Features)</h3>
<p>性能提升很棒, 我很喜欢 Swift 对于派发方式的优化. 但是, <code>UIView</code> 子类颜色的属性理论上性能的提升破坏了 UIKit 现有的模式.</p>
<blockquote>
<p>原文: However, having a theoretical performance boost in my <code>UIView</code> subclass color property breaking an established pattern in UIKit is damaging to the language.</p>
</blockquote>
<h3 id="NSObject-作为一个选择-NSObject-as-a-Choice"><a class="header-anchor" href="#NSObject-作为一个选择-NSObject-as-a-Choice">¶</a>NSObject 作为一个选择 (NSObject as a Choice)</h3>
<p>使用静态派发的话结构体是个不错的选择, 而使用消息机制派发的话则可以考虑 <code>NSObject</code>. 现在, 如果你想跟一个刚学 Swift 的开发者解释为什么某个东西是一个 <code>NSObject</code> 的子类, 你不得不去介绍 Objective-C 以及这段历史. 现在没有任何理由去继承 <code>NSObject</code> 构建类, 除非你需要使用 Objective-C 构建的框架.</p>
<p>目前, <code>NSObject</code> 在 Swift 里的派发方式, 一句话总结就是<strong>复杂</strong>, 跟理想还是有差距. 我比较想看到这个修改: 当你继承 <code>NSObject</code> 的时候, 这是一个你想要完全使用动态消息机制的表现.</p>
<h3 id="显式的动态性声明-Implicit-Dynamic-Modification"><a class="header-anchor" href="#显式的动态性声明-Implicit-Dynamic-Modification">¶</a>显式的动态性声明 (Implicit Dynamic Modification)</h3>
<p>另一个 Swift 可以改进的地方就是函数动态性的检测. 我觉得在检测到一个函数被 <code>#selector</code> 和 <code>#keypath</code> 引用时要自动把这些函数标记为 <code>dynamic</code>, 这样的话就会解决大部分 <code>UIAppearance</code> 的动态问题, 但也许有别的编译时的处理方式可以标记这些函数.</p>
<h2 id="Error-以及-Bug-Errors-and-Bugs"><a class="header-anchor" href="#Error-以及-Bug-Errors-and-Bugs">¶</a>Error 以及 Bug (Errors and Bugs)</h2>
<p>为了让我们对 Swift 的派发方式有更多了解, 让我们来看一下 Swift 开发者遇到过的 error.</p>
<h3 id="SR-584"><a class="header-anchor" href="#SR-584">¶</a>SR-584</h3>
<p>这个 <a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-584">Swift bug</a> 是 Swift 函数派发的一个功能. 存在于 <code>NSObject</code> 子类声明的函数(函数表派发), 以及声明在 extension 的函数(消息机制派发)中. 为了更好地描述这个情况, 我们先来创建一个类:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetings</span><span class="params">(person: Person)</span></span> &#123;</span><br><span class="line">    person.sayHi()</span><br><span class="line">&#125;</span><br><span class="line">greetings(person: <span class="type">Person</span>()) <span class="comment">// prints &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>greetings(person:)</code> 函数使用函数表派发来调用 <code>sayHi()</code>. 就像我们看到的, 期望的, “Hello” 会被打印. 没什么好讲的地方, 那现在让我们继承 <code>Persion</code>:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MisunderstoodPerson</span>: <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MisunderstoodPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;No one gets me.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetings(person: <span class="type">MisunderstoodPerson</span>()) <span class="comment">// prints &#x27;Hello&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>可以看到, sayHi() 函数是在 extension 里声明的, 会使用消息机制进行调用. 当greetings(person:) 被触发时, sayHi() 会通过函数表被派发到 Person 对象, 而misunderstoodPerson 重写之后会是用消息机制, 而 MisunderstoodPerson 的函数表依旧保留了 Person 的实现, 紧接着歧义就产生了.</strong></p>
<p>在这里的解决方法是保证函数使用相同的消息派发机制. 你可以给函数加上 <code>dynamic</code> 修饰符, 或者是把函数的实现从 extension 移动到类最初声明的作用域里.</p>
<p>理解了 Swift 的派发方式, 就能够理解这个行为产生的原因了, 虽然 Swift 不应该让我们遇到这个问题.</p>
<h3 id="SR-103"><a class="header-anchor" href="#SR-103">¶</a>SR-103</h3>
<p>这个 <a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-103">Swift bug</a> 触发了定义在协议拓展的默认实现, 即使是子类已经实现这个函数的情况下. 为了说明这个问题, 我们先定义一个协议, 并且给里面的函数一个默认实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greetings</span><span class="params">(greeter: Greetable)</span></span> &#123;</span><br><span class="line">    greeter.sayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在, 让我们定义一个遵守了这个协议的类. 先定义一个 <code>Person</code> 类, 遵守 <code>Greetable</code> 协议, 然后定义一个子类 <code>LoudPerson</code>, 重写 <code>sayHi()</code> 方法.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">Greetable</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoudPerson</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;HELLO&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你们发现 <code>LoudPerson</code> 实现的函数前面没有 <code>override</code> 修饰, 这是一个提示, 也许代码不会像我们设想的那样运行. 在这个例子里, <code>LoudPerson</code> 没有在 <code>Greetable</code> 的协议记录表(Protocol Witness Table)里成功注册, 当 <code>sayHi()</code> 通过 <code>Greetable</code> 协议派发时, 默认的实现就会被调用.</p>
<p>解决的方法就是, 在类声明的作用域里就要提供所有协议里定义的函数, 即使已经有默认实现. 或者, 你可以在类的前面加上一个 <code>final</code> 修饰符, 保证这个类不会被继承.</p>
<p>Doug Gregor 在 <a target="_blank" rel="noopener" href="https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html">Swift-Evolution 邮件列表</a>里提到, 通过显式地重新把函数声明为类的函数, 就可以解决这个问题, 并且不会偏离我们的设想.</p>
<h3 id="其它-bug-Other-bugs"><a class="header-anchor" href="#其它-bug-Other-bugs">¶</a>其它 bug (Other bugs)</h3>
<p>Another bug that I thought I’d mention is <a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-435">SR-435</a>. It involves two protocol extensions, where one extension is more specific than the other. The example in the bug shows one un-constrained extension, and one extension that is constrained to <code>Equatable</code> types. When the method is invoked inside a protocol, the more specific method is not called. I’m not sure if this always occurs or not, but seems important to keep an eye on.</p>
<p>另外一个 bug 我在 <a target="_blank" rel="noopener" href="https://bugs.swift.org/browse/SR-435">SR-435</a> 里已经提过了. 当有两个协议拓展, 而其中一个更加具体时就会触发. 例如, 有一个不受约束的 extension, 而另一个被 <code>Equatable</code> 约束, 当这个方法通过协议派发, 约束比较多的那个 extension 的实现则不会被调用. 我不太确定这是不是百分之百能复现, 但有必要留个心眼.</p>
<p>If you are aware of any other Swift dispatch bugs, <a target="_blank" rel="noopener" href="https://twitter.com/kingofbrian">drop me a line</a> and I’ll update this blog post.</p>
<p>如果你发现了其它 Swift 派发的 bug 的话, <a target="_blank" rel="noopener" href="https://twitter.com/kingofbrian">@一下我</a>我就会更新到这篇博客里.</p>
<h3 id="有趣的-Error-Interesting-Error"><a class="header-anchor" href="#有趣的-Error-Interesting-Error">¶</a>有趣的 Error (Interesting Error)</h3>
<p>有一个很好玩的编译错误, 可以窥见到 Swift 的计划. 就像之前说的, 类拓展使用直接派发, 所以你试图 override 一个声明在 extension 里的函数的时候会发生什么?</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubClass</span>: <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">extensionMethod</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码会触发一个编译错误 <code>Declarations in extensions can not be overridden yet</code>(声明在 extension 里的方法不可以被重写). 这可能是 Swift 团队打算加强函数表派发的一个征兆. 又或者这只是我过度解读, 觉得这门语言可以优化的地方.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我喝杯青岛吧~~~</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.png" alt="You Shaw 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.png" alt="You Shaw 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>You Shaw
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://blog.yshaw.cn/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/" title="【译文】swift 派发机制">http://blog.yshaw.cn/2018/06/21/【译文】swift派发机制/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/runtime/" rel="tag"># runtime</a>
              <a href="/tags/%E5%87%BD%E6%95%B0%E6%B4%BE%E5%8F%91/" rel="tag"># 函数派发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2018/06/04/Swift%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%96%B9%E6%B3%95%E8%B0%83%E5%BA%A6/" rel="prev" title="Swift内存模型和方法调度">
                  <i class="fa fa-chevron-left"></i> Swift内存模型和方法调度
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2018/06/23/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" rel="next" title="【译文】swift中的泛型编程">
                  【译文】swift中的泛型编程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">You Shaw</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  















  








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.0/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: "/2018/06/21/%E3%80%90%E8%AF%91%E6%96%87%E3%80%91swift%E6%B4%BE%E5%8F%91%E6%9C%BA%E5%88%B6/",
    }, {"enable":true,"appId":"lyxbzytuOmTmDs7t5xdJ0D8S-gzGzoHsz","appKey":"B6zz1OaMTwHI4mOd0QyucHXi","placeholder":"说点什么...","avatar":"wavatar","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-cn","visitor":true,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":false,"requiredFields":[]}
    ));
  }, window.Valine);
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
